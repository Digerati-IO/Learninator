<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/Grid.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/Grid.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function (global) {
    "use strict";

    /**
     * Create a cell
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @returns {Cell}
     * @name Cell
     * @constructor
     */
    var Cell = function (x, y, width, height) {
        this.x = x;
        this.y = y;
        this.visited = false;
        this.parent = null;
        this.heuristic = 0;
        this.reward = 0;
        this.population = [];
        this.populationCounts = {};

        this.coords = {
            top: {
                left: {
                    x: x * width,
                    y: y * height
                },
                right: {
                    x: x * width + width,
                    y: y * height
                }
            },
            bottom: {
                left: {
                    x: x * width,
                    y: y * height + height
                },
                right: {
                    x: x * width + width,
                    y: y * height + height
                }
            }
        };

        return this;
    };

    /**
     * Calculate the path to the origin
     *
     * @returns {Array}
     */
    Cell.prototype.pathToOrigin = function () {
        var path = [this],
            p = this.parent;

        while (p) {
            path.push(p);
            p = p.parent;
        }
        path.reverse();

        return path;
    };

    /**
     * Score
     *
     * @returns {Number}
     */
    Cell.prototype.score = function () {
        var total = 0,
            p = this.parent;

        while (p) {
            ++total;
            p = p.parent;
        }

        return total;
    };

    /**
     * Mark it as visited
     *
     * @return {undefined}
     */
    Cell.prototype.visit = function () {
        this.visited = true;

        return this;
    };

    /**
     * Grid
     *
     * @param {Object} env
     * @returns {Grid}
     * @name Grid
     * @constructor
     */
    var Grid = function (env) {
        this.xCount = env.xCount || 1;
        this.yCount = env.yCount || 1;
        this.cellWidth = env.width / this.xCount;
        this.cellHeight = env.height / this.yCount;

        this.removedEdges = [];
        this.cells = [];
        this.path = [];

        var row, c;
        for (let i = 0; i &lt; this.xCount; i++) {
            this.cells.push([]);
            row = this.cells[i];
            for (let j = 0; j &lt; this.yCount; j++) {
                c = new Cell(i, j, this.cellWidth, this.cellHeight);
                row.push(c);
            }
        }

        return this;
    };

    /**
     * Returns true if there is an edge between c1 and c2
     *
     * @param {Cell} c1
     * @param {Cell} c2
     * @returns {Boolean}
     */
    Grid.prototype.areConnected = function (c1, c2) {
        if (!c1 || !c2) {
            return false;
        }

        if (Math.abs(c1.x - c2.x) > 1 || Math.abs(c1.y - c2.y) > 1) {
            return false;
        }

        var removedEdge = _.detect(this.removedEdges, function (edge) {
            return _.include(edge, c1) &amp;&amp; _.include(edge, c2);
        });

        return removedEdge === undefined;
    };

    /**
     * Returns all neighbors of this Cell that are separated by an edge
     *
     * @param {Cell} c
     * @returns {Array}
     */
    Grid.prototype.connectedNeighbors = function (c) {
        var _this = this, con;
        return _.select(this.neighbors(c), function (c0) {
            con = _this.areConnected(c, c0);

            return con;
        });
    };

    /**
     * Returns all neighbors of this Cell that are NOT separated by an edge
     * This means there is a maze path between both cells.
     *
     * @param {Cell} c
     * @returns {Array}
     */
    Grid.prototype.disconnectedNeighbors = function (c) {
        var _this = this, disc;
        return _.reject(this.neighbors(c), function (c0) {
            disc = _this.areConnected(c, c0);

            return disc;
        });
    };

    /**
     * Get a Cell at a specific point
     *
     * @param {Number} x
     * @param {Number} y
     * @returns {Cell}
     */
    Grid.prototype.getCellAt = function (x, y) {
        if (x >= this.xCount || y >= this.yCount || x &lt; 0 || y &lt; 0 || !this.cells[x]) {
            return null;
        }

        return this.cells[x][y];
    };

    /**
     * Get the distance between two Cell
     *
     * @param {Cell} c1
     * @param {Cell} c2
     * @returns {Number}
     */
    Grid.prototype.getCellDistance = function (c1, c2) {
        var xDist = Math.abs(c1.x - c2.x),
            yDist = Math.abs(c1.y - c2.y);

        return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
    };

    /**
     * Return the centered location of the entity within a grid
     *
     * @param {Cell} c
     * @returns {Object}
     */
    Grid.prototype.getPositionFromGridLocation = function (c) {
        let x = c.coords.bottom.right.x - (this.cellWidth / 2),
            y = c.coords.bottom.right.y - (this.cellHeight / 2);

        return new Vec(x, y);
    };

    /**
     * Return the location of the entity within a grid
     *
     * @param {Object} entity
     * @returns {Object}
     */
    Grid.prototype.getGridLocation = function (entity) {
        var xCell, yCell;
        for (let x = 0; x &lt; this.xCount; x++) {
            xCell = this.cells[x];
            for (let y = 0; y &lt; this.yCount; y++) {
                yCell = xCell[y];
                if ((entity.position.x >= yCell.coords.top.left.x &amp;&amp; entity.position.x &lt;= yCell.coords.bottom.right.x) &amp;&amp;
                    (entity.position.y >= yCell.coords.top.left.y &amp;&amp; entity.position.y &lt;= yCell.coords.bottom.right.y)) {
                    entity.gridLocation = this.cells[x][y];

                    return entity;
                }
            }
        }
    };

    /**
     * Returns all neighbors of this cell, regardless if they are connected or not.
     *
     * @param {Cell} c
     * @returns {Array}
     */
    Grid.prototype.neighbors = function (c) {
        var neighbors = [],
            topCell = this.getCellAt(c.x, c.y - 1),
            rightCell = this.getCellAt(c.x + 1, c.y),
            bottomCell = this.getCellAt(c.x, c.y + 1),
            leftCell = this.getCellAt(c.x - 1, c.y);

        if (c.y > 0 &amp;&amp; topCell) {
            neighbors.push(topCell);
        }
        if (c.x &lt; this.xCount &amp;&amp; rightCell) {
            neighbors.push(rightCell);
        }
        if (c.y &lt; this.yCount &amp;&amp; bottomCell) {
            neighbors.push(bottomCell);
        }
        if (c.x > 0 &amp;&amp; leftCell) {
            neighbors.push(leftCell);
        }

        return neighbors;
    };

    /**
     * Remove the edge from between two Cells
     *
     * @param {Cell} c1
     * @param {Cell} c2
     * @returns {undefined}
     */
    Grid.prototype.removeEdgeBetween = function (c1, c2) {
        this.removedEdges.push([c1, c2]);
    };

    /**
     * Returns all neighbors of this Cell that aren't separated by an edge
     *
     * @param {Cell} c
     * @returns {unresolved}
     */
    Grid.prototype.unvisitedNeighbors = function (c) {
        var unv;
        return _.select(this.connectedNeighbors(c), function (c0) {
            unv = !c0.visited;
            return unv;
        });
    };

    global.Cell = Cell;
    global.Grid = Grid;

}(this));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_anonymous_-WaterWorldGA-Trainer.html">Trainer</a></li><li><a href="Agent.html">Agent</a></li><li><a href="AgentGA.html">AgentGA</a></li><li><a href="AgentRLDQN.html">AgentRLDQN</a></li><li><a href="AgentRLTD.html">AgentRLTD</a></li><li><a href="AgentTD.html">AgentTD</a></li><li><a href="Bitmap.html">Bitmap</a></li><li><a href="Button.html">Button</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Cell.html">Cell</a></li><li><a href="Chromosome.html">Chromosome</a></li><li><a href="CollisionDetector.html">CollisionDetector</a></li><li><a href="datGUI.html">datGUI</a></li><li><a href="DeterministPG.html">DeterministPG</a></li><li><a href="DPAgent.html">DPAgent</a></li><li><a href="DQNAgent.html">DQNAgent</a></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityRLDQN.html">EntityRLDQN</a></li><li><a href="ESPNet.html">ESPNet</a></li><li><a href="ESPTrainer.html">ESPTrainer</a></li><li><a href="Experience.html">Experience</a></li><li><a href="Eye.html">Eye</a></li><li><a href="GATrainer.html">GATrainer</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Grid.html">Grid</a></li><li><a href="GridWorld.html">GridWorld</a></li><li><a href="Interactions.html">Interactions</a></li><li><a href="Map.html">Map</a></li><li><a href="Mat.html">Mat</a></li><li><a href="Maze.html">Maze</a></li><li><a href="MazeWorld.html">MazeWorld</a></li><li><a href="Menu.html">Menu</a></li><li><a href="Player.html">Player</a></li><li><a href="PuckWorld.html">PuckWorld</a></li><li><a href="QuadTree.html">QuadTree</a></li><li><a href="RecurrentReinforceAgent.html">RecurrentReinforceAgent</a></li><li><a href="RewardGraph.html">RewardGraph</a></li><li><a href="SimpleReinforceAgent.html">SimpleReinforceAgent</a></li><li><a href="Solver.html">Solver</a></li><li><a href="TDAgent.html">TDAgent</a></li><li><a href="TDBrain.html">TDBrain</a></li><li><a href="UI.html">UI</a></li><li><a href="Vec.html">Vec</a></li><li><a href="Wall.html">Wall</a></li><li><a href="WaterWorld.html">WaterWorld</a></li><li><a href="WaterWorldEX.html">WaterWorldEX</a></li><li><a href="WaterWorldGA.html">WaterWorldGA</a></li><li><a href="Window.html">Window</a></li><li><a href="World.html">World</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#findInsertNode">findInsertNode</a></li><li><a href="global.html#findOverlappingNodes">findOverlappingNodes</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#retrieve">retrieve</a></li><li><a href="global.html#Utility">Utility</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Oct 22 2015 15:27:15 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
