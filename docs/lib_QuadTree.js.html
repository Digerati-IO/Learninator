<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/QuadTree.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/QuadTree.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var QuadTree = {}; // global var for the quadtree

(function (global) {
    "use strict";
    /**
     * Usage:
     * To create a new empty Quadtree, do this:
     * var tree = new QuadTree(args)
     *
     * args = {
     *    // mandatory fields
     *    x : x coordinate
     *    y : y coordinate
     *    width : width
     *    height : height
     *
     *    // optional fields
     *    maxChildren : max children per node
     *    maxDepth : max depth of the tree
     *}
     *
     * API:
     * tree.insert() accepts arrays or single items every item must have a
     * .position.x, .position.y, .width, and .height property.
     * if they don't, the tree will break.
     *
     * tree.retrieve(selector, callback) calls the callback for all objects that are in
     * the same region or overlapping.
     *
     * tree.clear() removes all items from the quadtree.
     */

    /**
     * QuadTree Implementation in JavaScript
     * @author: silflow &lt;https://github.com/silflow>
     * @name QuadTree
     * @constructor
     */
    var QuadTree = function (args) {
        var node,
            TOP_LEFT = 0,
            TOP_RIGHT = 1,
            BOTTOM_LEFT = 2,
            BOTTOM_RIGHT = 3,
            PARENT = 4;

        // Assign some default values
        args.maxChildren = args.maxChildren || 2;
        args.maxDepth = args.maxDepth || 8;

        /**
         * Node creator.
         * You should never create a node manually since the algorithm takes care of that for you.
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         * @param {Number} depth
         * @param {Number} maxChildren
         * @param {Number} maxDepth
         * @returns {{x: *, y: *, width: *, height: *, depth: *, retrieve: Function, insert: Function, findInsertNode: Function, findOverlappingNodes: Function, divide: Function, clear: Function, getNodes: Function}}
         */
        node = function (x, y, width, height, depth, maxChildren, maxDepth) {
            var items = [], // holds all items
                nodes = []; // holds all child nodes

            // returns a fresh node object
            return {
                x: x, // top left point
                y: y, // top right point
                width: width, // width
                height: height, // height
                depth: depth, // depth level of the node

                /**
                 * Iterates all items that match the selector and invokes the supplied callback on them.
                 * @param {Array|Object} item
                 * @param {Function} callback
                 * @param {Node} instance
                 */
                retrieve: function (item, callback, instance) {
                    for (let i = 0, il = items.length; i &lt; il; ++i) {
                        (instance) ? callback.call(instance, items[i]) : callback(items[i]);
                    }
                    // check if node has subnodes
                    if (nodes.length) {
                        // call retrieve on all matching subnodes
                        this.findOverlappingNodes(item, function (dir) {
                            nodes[dir].retrieve(item, callback, instance);
                        });
                    }
                },

                /**
                 * Adds a new Item to the node.
                 *
                 * If the node already has sub nodes, the item gets pushed down one level.
                 * If the item does not fit into the sub nodes, it gets saved in the
                 * "children"-array.
                 *
                 * If the maxChildren limit is exceeded after inserting the item,
                 * the node gets divided and all items inside the "children"-array get
                 * pushed down to the new sub nodes.
                 * @param {Array|Object} item
                 */
                insert: function (item) {
                    if (nodes.length) {
                        // Get the node in which the item fits best
                        let i = this.findInsertNode(item);
                        if (i === PARENT) {
                            // If the item does not fit, push it into the children array
                            items.push(item);
                        } else {
                            nodes[i].insert(item);
                        }
                    } else {
                        items.push(item);
                        // Divide the node if maxChildren is exceeded and maxDepth is not reached
                        if (items.length > maxChildren &amp;&amp; this.depth &lt; maxDepth) {
                            this.divide();
                        }
                    }
                },

                /**
                 * Find a node the item should be inserted in.
                 * @param {Array|Object} item
                 * @returns {Number}
                 */
                findInsertNode: function (item) {
                    let wD = this.width / 2,
                        hD = this.height / 2;
                    if (item.radius !== undefined) {
                        // Left
                        if (item.position.x &lt; this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                return TOP_LEFT;
                            }
                            if (item.position.y + item.radius >= this.y + hD) {
                                return BOTTOM_LEFT;
                            }
                            return PARENT;
                        }
                        // Right
                        if (item.position.x + item.radius >= this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                return TOP_RIGHT;
                            }
                            if (item.position.y + item.radius >= this.y + hD) {
                                return BOTTOM_RIGHT;
                            }
                            return PARENT;
                        }
                    } else {
                        // Left
                        if (item.position.x + item.width &lt; this.x + wD) {
                            if (item.position.y + item.height &lt; this.y + hD) {
                                return TOP_LEFT;
                            }
                            if (item.position.y >= this.y + hD) {
                                return BOTTOM_LEFT;
                            }
                            return PARENT;
                        }
                        // Right
                        if (item.position.x >= this.x + wD) {
                            if (item.position.y + item.height &lt; this.y + hD) {
                                return TOP_RIGHT;
                            }
                            if (item.position.y >= this.y + hD) {
                                return BOTTOM_RIGHT;
                            }
                            return PARENT;
                        }
                    }

                    return PARENT;
                },
                /**
                 * Finds the regions that the item overlaps with, see constants defined
                 * above. The callback is called for every region the item overlaps.
                 * @param {Array|Object} item
                 * @param {Function} callback
                 */
                findOverlappingNodes: function (item, callback) {
                    let wD = this.width / 2,
                        hD = this.height / 2;
                    if (item.radius !== undefined) {
                        // Left
                        if (item.position.x &lt; this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                callback(TOP_LEFT);
                            }
                            if (item.position.y + item.radius >= this.y + hD) {
                                callback(BOTTOM_LEFT);
                            }
                        }
                        // Right
                        if (item.position.x + item.radius >= this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                callback(TOP_RIGHT);
                            }
                            if (item.position.y + item.radius >= this.y + hD) {
                                callback(BOTTOM_RIGHT);
                            }
                        }
                    } else {
                        // Left
                        if (item.position.x &lt; this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                callback(TOP_LEFT);
                            }
                            if (item.position.y + item.height >= this.y + hD) {
                                callback(BOTTOM_LEFT);
                            }
                        }
                        // Right
                        if (item.position.x + item.width >= this.x + wD) {
                            if (item.position.y &lt; this.y + hD) {
                                callback(TOP_RIGHT);
                            }
                            if (item.position.y + item.height >= this.y + hD) {
                                callback(BOTTOM_RIGHT);
                            }
                        }
                    }
                },

                /**
                 * Divides the current node into four sub nodes and adds them
                 * to the nodes array of the current node. Then reinserts all
                 * children.
                 */
                divide: function () {
                    let width, height, oldChildren,
                        childrenDepth = this.depth + 1;
                    // Set the dimensions of the new nodes
                    width = (this.width / 2);
                    height = (this.height / 2);
                    // Create top left node
                    nodes.push(node(this.x, this.y, width, height, childrenDepth, maxChildren, maxDepth));
                    // Create top right node
                    nodes.push(node(this.x + width, this.y, width, height, childrenDepth, maxChildren, maxDepth));
                    // Create bottom left node
                    nodes.push(node(this.x, this.y + height, width, height, childrenDepth, maxChildren, maxDepth));
                    // Create bottom right node
                    nodes.push(node(this.x + width, this.y + height, width, height, childrenDepth, maxChildren, maxDepth));

                    oldChildren = items;
                    items = [];
                    for (let i = 0; i &lt; oldChildren.length; i++) {
                        this.insert(oldChildren[i]);
                    }
                },

                /**
                 * Clears the node and all its sub nodes.
                 */
                clear: function () {
                    var i;
                    for (i = 0; i &lt; nodes.length; i++) {
                        nodes[i].clear();
                    }
                    items.length = 0;
                    nodes.length = 0;
                },

                /*
                 * Convenience method that is not used in the core algorithm.
                 * ---------------------------------------------------------
                 * This returns this nodes sub nodes. this is useful if we want to do stuff
                 * with the nodes, i.e. accessing the bounds of the nodes to draw them
                 * on a canvas for debugging etc...
                 */
                getNodes: function () {
                    return nodes.length ? nodes : false;
                }
            };
        };

        return {
            root: (function () {
                return node(args.x, args.y, args.width, args.height, 0, args.maxChildren, args.maxDepth);
            }()),
            /**
             * Insert an item into the node
             * @param {Array|Object} item
             */
            insert: function (item) {
                if (item instanceof Array) {
                    for (let i = 0, len = item.length; i &lt; len; i++) {
                        this.root.insert(item[i]);
                    }
                } else {
                    this.root.insert(item);
                }
            },
            /**
             * Retrieve an item from the QuadTree
             * @param {Array|Object} selector
             * @param {Function} callback
             * @param {Node} instance
             * @returns {Node}
             */
            retrieve: function (selector, callback, instance) {
                return this.root.retrieve(selector, callback, instance);
            },
            /**
             * Clear the QuadTree
             */
            clear: function () {
                this.root.clear();
            }
        };
    };

    global.QuadTree = QuadTree;

}(this));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_anonymous_-WaterWorldGA-Trainer.html">Trainer</a></li><li><a href="Agent.html">Agent</a></li><li><a href="AgentGA.html">AgentGA</a></li><li><a href="AgentRLDQN.html">AgentRLDQN</a></li><li><a href="AgentRLTD.html">AgentRLTD</a></li><li><a href="AgentTD.html">AgentTD</a></li><li><a href="Bitmap.html">Bitmap</a></li><li><a href="Button.html">Button</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Cell.html">Cell</a></li><li><a href="Chromosome.html">Chromosome</a></li><li><a href="CollisionDetector.html">CollisionDetector</a></li><li><a href="datGUI.html">datGUI</a></li><li><a href="DeterministPG.html">DeterministPG</a></li><li><a href="DPAgent.html">DPAgent</a></li><li><a href="DQNAgent.html">DQNAgent</a></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityRLDQN.html">EntityRLDQN</a></li><li><a href="ESPNet.html">ESPNet</a></li><li><a href="ESPTrainer.html">ESPTrainer</a></li><li><a href="Experience.html">Experience</a></li><li><a href="Eye.html">Eye</a></li><li><a href="GATrainer.html">GATrainer</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Grid.html">Grid</a></li><li><a href="GridWorld.html">GridWorld</a></li><li><a href="Interactions.html">Interactions</a></li><li><a href="Map.html">Map</a></li><li><a href="Mat.html">Mat</a></li><li><a href="Maze.html">Maze</a></li><li><a href="MazeWorld.html">MazeWorld</a></li><li><a href="Menu.html">Menu</a></li><li><a href="Player.html">Player</a></li><li><a href="PuckWorld.html">PuckWorld</a></li><li><a href="QuadTree.html">QuadTree</a></li><li><a href="RecurrentReinforceAgent.html">RecurrentReinforceAgent</a></li><li><a href="RewardGraph.html">RewardGraph</a></li><li><a href="SimpleReinforceAgent.html">SimpleReinforceAgent</a></li><li><a href="Solver.html">Solver</a></li><li><a href="TDAgent.html">TDAgent</a></li><li><a href="TDBrain.html">TDBrain</a></li><li><a href="UI.html">UI</a></li><li><a href="Vec.html">Vec</a></li><li><a href="Wall.html">Wall</a></li><li><a href="WaterWorld.html">WaterWorld</a></li><li><a href="WaterWorldEX.html">WaterWorldEX</a></li><li><a href="WaterWorldGA.html">WaterWorldGA</a></li><li><a href="Window.html">Window</a></li><li><a href="World.html">World</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#findInsertNode">findInsertNode</a></li><li><a href="global.html#findOverlappingNodes">findOverlappingNodes</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#retrieve">retrieve</a></li><li><a href="global.html#Utility">Utility</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Oct 22 2015 15:19:49 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
