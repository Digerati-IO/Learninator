<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/Maze.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/Maze.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Original code borrowed from https://github.com/felipecsl/random-maze-generator
 */
(function (global) {
    "use strict";

    /**
     * Options for the Maze
     * @typedef {Object} mazeOpts
     * @property {number} opts.xCount - The horizontal Cell count
     * @property {number} opts.yCount - The vertical Cell count
     * @property {number} width - The width
     * @property {number} height - The height
     */

    /**
     * A maze generator
     * @name Maze
     * @constructor
     *
     * @param {mazeOpts} opts - The options for the Maze
     * @returns {Maze}
     */
    var Maze = function (opts) {
        this.xCount = Utility.getOpt(opts, 'xCount', 6);
        this.yCount = Utility.getOpt(opts, 'yCount', 6);
        this.width = Utility.getOpt(opts, 'width', 600);
        this.height = Utility.getOpt(opts, 'height', 600);
        this.cellWidth = this.width / this.xCount;
        this.cellHeight = this.height / this.yCount;

        this.walls = [];
        this.cellStack = [];
        this.path = [];

        this.grid = new Grid(opts);

        this.draw(opts.closed);

        this.solve();

        return this;
    };

    Maze.prototype = {
        /**
         * Add a Wall to the Maze
         * @param {Vec} v1
         * @param {Vec} v2
         * @returns {Maze}
         */
        addWall: function (v1, v2) {
            this.walls.push(new Wall(v1, v2));

            return this;
        },
        /**
         * Return the walls
         * @returns {Array}
         */
        walls: function () {
            return this.walls;
        },
        /**
         * Return the Graph's Cells
         * @returns {Array}
         */
        graphCells: function () {
            return this.grid.cells;
        },
        /**
         * Draw it
         * @returns {Maze}
         */
        draw: function (closed) {
            this.generate();
            this.drawBorders(closed);
            this.drawMaze();

            return this;
        },
        /**
         * Draw the borders
         * @returns {Maze}
         */
        drawBorders: function (closed) {
            this.addWall(new Vec(closed ? 0 : this.cellWidth, 0), new Vec(this.width, 0));
            this.addWall(new Vec(this.width, 0), new Vec(this.width, this.height));
            this.addWall(new Vec(this.width - (closed ? 0 : this.cellWidth), this.height), new Vec(0, this.height));
            this.addWall(new Vec(0, this.height), new Vec(0, 0));

            return this;
        },
        /**
         * Draw the solution
         * @param {Canvas} canvas
         * @returns {Maze}
         */
        drawSolution: function (canvas) {
            let V, vW, vH, vX, vY, x, y,
                _ctx = canvas.getContext("2d"),
                _this = this,
                path = this.path;
            _ctx.fillStyle = "rgba(0,165,0,.1)";
            _ctx.strokeStyle = "rgb(0,0,0)";
            for (let i = 0; i &lt; this.path.length; i++) {
                V = path[i];
                vW = this.cellWidth;
                vH = this.cellHeight;
                vX = V.x;
                vY = V.y;
                // Get the cell X coords and multiply by the cell width
                x = _this.grid.cells[vX][vY].x * vW;
                // Get the cell Y coords and multiply by the cell height
                y = _this.grid.cells[vX][vY].y * vH;

                (function () {
                    _ctx.fillRect(x, y, vW, vH);
                })();
            }

            return this;
        },
        /**
         * Draw the Maze
         * @returns {Maze}
         */
        drawMaze: function () {
            let grid = this.grid,
                drawnEdges = [],
                x1, y1, x2, y2,
                v, topV, leftV, rightV, bottomV;

            let edgeAlreadyDrawn = function (v1, v2) {
                return _.detect(drawnEdges, function (edge) {
                        return _.include(edge, v1) &amp;&amp; _.include(edge, v2);
                    }) !== undefined;
            };

            for (let i = 0; i &lt; grid.xCount; i++) {
                for (let j = 0; j &lt; grid.yCount; j++) {
                    v = grid.cells[i][j];
                    topV = grid.getCellAt(v.x, v.y - 1);
                    leftV = grid.getCellAt(v.x - 1, v.y);
                    rightV = grid.getCellAt(v.x + 1, v.y);
                    bottomV = grid.getCellAt(v.x, v.y + 1);

                    if (!edgeAlreadyDrawn(v, topV) &amp;&amp; grid.areConnected(v, topV)) {
                        x1 = v.x * this.cellWidth;
                        y1 = v.y * this.cellHeight;
                        x2 = x1 + this.cellWidth;
                        y2 = y1;

                        this.addWall(new Vec(x1, y1), new Vec(x2, y2));
                        drawnEdges.push([v, topV]);
                    }

                    if (!edgeAlreadyDrawn(v, leftV) &amp;&amp; grid.areConnected(v, leftV)) {
                        x2 = x1;
                        y2 = y1 + this.cellHeight;

                        this.addWall(new Vec(x1, y1), new Vec(x2, y2));
                        drawnEdges.push([v, leftV]);
                    }

                    if (!edgeAlreadyDrawn(v, rightV) &amp;&amp; grid.areConnected(v, rightV)) {
                        x1 = (v.x * this.cellWidth) + this.cellWidth;
                        y1 = v.y * this.cellHeight;
                        x2 = x1;
                        y2 = y1 + this.cellHeight;

                        this.addWall(new Vec(x1, y1), new Vec(x2, y2));
                        drawnEdges.push([v, rightV]);
                    }

                    if (!edgeAlreadyDrawn(v, bottomV) &amp;&amp; grid.areConnected(v, bottomV)) {
                        x1 = v.x * this.cellWidth;
                        y1 = (v.y * this.cellHeight) + this.cellHeight;
                        x2 = x1 + this.cellWidth;
                        y2 = y1;

                        this.addWall(new Vec(x1, y1), new Vec(x2, y2));
                        drawnEdges.push([v, bottomV]);
                    }
                }
            }

            return this;
        },
        /**
         * Build the maze
         * @returns {Maze}
         */
        generate: function () {
            var initialCell = this.grid.getCellAt(0, 0);
            this.recurse(initialCell);

            return this;
        },
        /**
         * Recurse through a Cell's neighbors
         * @param {Cell} cell
         * @returns {Maze}
         */
        recurse: function (cell) {
            cell.visit();
            let neighbors = this.grid.unvisitedNeighbors(cell);
            if (neighbors.length > 0) {
                let randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                this.cellStack.push(cell);
                this.grid.removeEdgeBetween(cell, randomNeighbor);
                this.recurse(randomNeighbor);
            } else {
                let waitingCell = this.cellStack.pop();
                if (waitingCell) {
                    this.recurse(waitingCell);
                }
            }

            return this;
        },
        /**
         * Solve the Maze
         * @returns {Maze}
         */
        solve: function () {
            let closedSet = [],
            // Top left cell
                startCell = this.grid.getCellAt(0, 0),
            // Bottom right cell
                targetCell = this.grid.getCellAt(this.xCount - 1, this.yCount - 1),
                openSet = [startCell],
                searchCell = startCell,
                neighbors, neighbor;

            while (openSet.length > 0) {
                neighbors = this.grid.disconnectedNeighbors(searchCell);
                for (let i = 0; i &lt; neighbors.length; i++) {
                    neighbor = neighbors[i];
                    if (neighbor === targetCell) {
                        neighbor.parent = searchCell;
                        this.path = neighbor.pathToOrigin();
                        this.grid.path = this.path;
                        openSet = [];
                        return;
                    }
                    if (!_.include(closedSet, neighbor)) {
                        if (!_.include(openSet, neighbor)) {
                            openSet.push(neighbor);
                            neighbor.parent = searchCell;
                            neighbor.heuristic = neighbor.score() + this.grid.getCellDistance(neighbor, targetCell);
                        }
                    }
                }
                closedSet.push(searchCell);
                openSet.remove(_.indexOf(openSet, searchCell));
                searchCell = null;

                _.each(openSet, function (cell) {
                    if (!searchCell) {
                        searchCell = cell;
                    } else if (searchCell.heuristic > cell.heuristic) {
                        searchCell = cell;
                    }
                });
            }

            return this;
        }
    };

    global.Maze = Maze;

}(this));</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a></li><li><a href="AgentGA.html">AgentGA</a></li><li><a href="AgentRLDQN.html">AgentRLDQN</a></li><li><a href="AgentRLTD.html">AgentRLTD</a></li><li><a href="AgentTD.html">AgentTD</a></li><li><a href="Bitmap.html">Bitmap</a></li><li><a href="BruteCD.html">BruteCD</a></li><li><a href="Button.html">Button</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Cell.html">Cell</a></li><li><a href="Chromosome.html">Chromosome</a></li><li><a href="CollisionDetector.html">CollisionDetector</a></li><li><a href="datGUI.html">datGUI</a></li><li><a href="DeterministPG.html">DeterministPG</a></li><li><a href="Display.html">Display</a></li><li><a href="DPAgent.html">DPAgent</a></li><li><a href="DQNAgent.html">DQNAgent</a></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityRLDQN.html">EntityRLDQN</a></li><li><a href="ESPNet.html">ESPNet</a></li><li><a href="ESPTrainer.html">ESPTrainer</a></li><li><a href="Eye.html">Eye</a></li><li><a href="GATrainer.html">GATrainer</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Grid.html">Grid</a></li><li><a href="GridCD.html">GridCD</a></li><li><a href="GridWorld.html">GridWorld</a></li><li><a href="HeCubex.html">HeCubex</a></li><li><a href="Hex.html">Hex</a></li><li><a href="HexGrid.html">HexGrid</a></li><li><a href="HexWorld.html">HexWorld</a></li><li><a href="Interactions.html">Interactions</a></li><li><a href="Map.html">Map</a></li><li><a href="Mat.html">Mat</a></li><li><a href="Maze.html">Maze</a></li><li><a href="MazeWorld.html">MazeWorld</a></li><li><a href="Menu.html">Menu</a></li><li><a href="Player.html">Player</a></li><li><a href="Point.html">Point</a></li><li><a href="PuckWorld.html">PuckWorld</a></li><li><a href="QuadCD.html">QuadCD</a></li><li><a href="QuadTree.html">QuadTree</a></li><li><a href="RecurrentReinforceAgent.html">RecurrentReinforceAgent</a></li><li><a href="RewardGraph.html">RewardGraph</a></li><li><a href="SimpleReinforceAgent.html">SimpleReinforceAgent</a></li><li><a href="Solver.html">Solver</a></li><li><a href="TDAgent.html">TDAgent</a></li><li><a href="Vec.html">Vec</a></li><li><a href="Wall.html">Wall</a></li><li><a href="WaterWorld.html">WaterWorld</a></li><li><a href="WaterWorldEX.html">WaterWorldEX</a></li><li><a href="WaterWorldGA.html">WaterWorldGA</a></li><li><a href="Window.html">Window</a></li><li><a href="World.html">World</a></li><li><a href="%257Bobject%257D%2520input.html">{object} input</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#EZGUI">EZGUI</a></li><li><a href="global.html#findByAngle">findByAngle</a></li><li><a href="global.html#findByName">findByName</a></li><li><a href="global.html#findInsertNode">findInsertNode</a></li><li><a href="global.html#findOverlappingNodes">findOverlappingNodes</a></li><li><a href="global.html#initSensors">initSensors</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#isAndroid">isAndroid</a></li><li><a href="global.html#isChrome">isChrome</a></li><li><a href="global.html#isFirefox">isFirefox</a></li><li><a href="global.html#isGecko">isGecko</a></li><li><a href="global.html#isIE">isIE</a></li><li><a href="global.html#isIOS">isIOS</a></li><li><a href="global.html#isIPad">isIPad</a></li><li><a href="global.html#isIPhone">isIPhone</a></li><li><a href="global.html#isIPod">isIPod</a></li><li><a href="global.html#isKindle">isKindle</a></li><li><a href="global.html#isMobile">isMobile</a></li><li><a href="global.html#isOpera">isOpera</a></li><li><a href="global.html#isSafari">isSafari</a></li><li><a href="global.html#isTablet">isTablet</a></li><li><a href="global.html#isTV">isTV</a></li><li><a href="global.html#isWebKit">isWebKit</a></li><li><a href="global.html#resetSensors">resetSensors</a></li><li><a href="global.html#retrieve">retrieve</a></li><li><a href="global.html#Utility">Utility</a></li><li><a href="global.html#whoami">whoami</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Dec 03 2015 10:30:02 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
